/*
 * Project home: https://github.com/jaxio/celerio-angular-quickstart
 *
 * Source code generated by Celerio, an Open Source code generator by Jaxio.
 * Documentation: http://www.jaxio.com/documentation/celerio/
 * Modificado por CARLOS BAZALAR
 * Email: cbazalarlarosa@gmail.com
 * Template pack-angular:src/main/java/rest/EntitydeltaResource.java.e.vm
 */
package com.incloud.hcp.rest.delta;

import com.incloud.hcp.cmis.CmisFile;
import com.incloud.hcp.common.BindingErrorsResponse;
import com.incloud.hcp.domain.FacDocumentoAdjunto;
import com.incloud.hcp.domain.FacFactura;
import com.incloud.hcp.domain.response.FacFacturaResponse;
import com.incloud.hcp.enums.TipoFacturaAdjuntoEnum;
import com.incloud.hcp.rest.FacFacturaRest;
import com.incloud.hcp.service.delta.FacFacturaDeltaService;
import com.incloud.hcp.service.dto.DatosProveedorSunatDto;
import com.incloud.hcp.service.dto.FacFacturaDto;
import com.incloud.hcp.service.dto.MensajePrefactura;
import com.incloud.hcp.service.dto.PrefacturaDto;
import com.incloud.hcp.service.support.PageResponse;
import com.incloud.hcp.service.wsdlSunat.BillConsultPortBidingServiceLocator;
import com.incloud.hcp.service.wsdlSunat.BillConsultService;
import com.incloud.hcp.service.wsdlSunat.StatusResponse;
import com.incloud.hcp.service.wsdlSunat.flyWeight.FunctionsXML;
import com.incloud.hcp.util.Utils;
import com.incloud.hcp.utils.DateUtils;
import com.incloud.hcp.utils.NumberUtils;
import io.swagger.annotations.ApiOperation;
import org.apache.axis.client.Stub;
import org.apache.axis.message.MessageElement;
import org.apache.axis.message.PrefixedQName;
import org.apache.axis.message.SOAPHeaderElement;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;
import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.net.URISyntaxException;
import java.util.*;

import static org.springframework.http.MediaType.APPLICATION_JSON_VALUE;

@RestController
@RequestMapping("/api/facFactura")
public class FacFacturaDeltaRest extends FacFacturaRest {

    private final Logger log = LoggerFactory.getLogger(FacFacturaDeltaRest.class);

    @Autowired
    protected FacFacturaDeltaService facFacturaDeltaService;

    @Autowired
    protected FacFacturaDeltaService facFacturaDeltaRepository;

    @Value("${cfg.sunat.user}")
    private String repositoryUser;

    @Value("${cfg.sunat.pass}")
    private String repositoryPass;


    @GetMapping(value = "/_devuelveDatosProveedorSunat/{rucProveedor}", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<DatosProveedorSunatDto> devuelveDatosProveedorSunat(@PathVariable("rucProveedor") String rucProveedor) {
        HttpHeaders headers = new HttpHeaders();
        try {
            return Optional.ofNullable(this.facFacturaDeltaService.devuelveDatosProveedorSunat(rucProveedor))
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        } catch (Exception e) {
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(e);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }


    @ApiOperation(value = "Valida Comprobante XML", produces = "application/json")
    @PostMapping(value = "/_validarComprobante",produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ResponseEntity<MensajePrefactura> VerificarComprobanteRest(@RequestParam(value = "file") MultipartFile archivoSunat){
        MensajePrefactura bean = new MensajePrefactura();
        String codess;
        String messages;
        String serieComprobante;
        String nroComprobante;
        PrefacturaDto prefactura = new PrefacturaDto();

        try {
            File sunatXml = FunctionsXML.convert(archivoSunat);
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();
            Document doc = db.parse(sunatXml);

            XPath xPath = XPathFactory.newInstance().newXPath();
            String referenciaFactura = xPath.compile("/Invoice/ID").evaluate(doc);
            String igvAlt = xPath.compile("/Invoice/TaxTotal/TaxAmount").evaluate(doc);
            String rucProveedorAlt = xPath.compile("/Invoice/AccountingSupplierParty/Party/PartyIdentification/ID").evaluate(doc);
            String rucClienteAlt = xPath.compile("/Invoice/AccountingCustomerParty/Party/PartyIdentification/ID").evaluate(doc);

            doc.getDocumentElement().normalize();
            NodeList ProveedorNodeList = doc.getElementsByTagName("cac:AccountingSupplierParty");
            NodeList ClienteNodeList = doc.getElementsByTagName("cac:AccountingCustomerParty");
            NodeList FacturaNodeList = doc.getElementsByTagName("Invoice");
            NodeList TaxSubTotalNodeList = doc.getElementsByTagName("cac:TaxTotal");
            NodeList TaxTotalNodeList = doc.getElementsByTagName("cac:LegalMonetaryTotal");

            String rucProveedor = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:ID");
            String rucCliente = FunctionsXML.getTagValueHTML(ClienteNodeList, "cbc:ID");

            if(!NumberUtils.stringIsLong(rucProveedor) && rucProveedor.length() != 11){
                rucProveedor = rucProveedorAlt;
            }

            if(!NumberUtils.stringIsLong(rucCliente) && rucCliente.length() != 11){
                rucCliente = rucClienteAlt;
            }

            String tipoComprobante = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:InvoiceTypeCode");
            String montoTotal = FunctionsXML.getTagValueHTML(TaxTotalNodeList, "cbc:PayableAmount");
            List<String> taxSubTotalList = FunctionsXML.getTagValueIntoTagHTML(TaxSubTotalNodeList, "cbc:Name", "IGV", "cbc:TaxAmount","cbc:TaxableAmount" );
            String igv = taxSubTotalList.get(0);
            String subTotal = taxSubTotalList.get(1);

            if(!NumberUtils.stringIsBigDecimal(igv) || ((new BigDecimal(igv).compareTo(BigDecimal.ZERO)) == 0 && (new BigDecimal(igvAlt).compareTo(BigDecimal.ZERO)) > 0)) {
                igv = igvAlt;
            }

            if(!NumberUtils.stringIsBigDecimal(subTotal) || ((new BigDecimal(subTotal).compareTo(BigDecimal.ZERO)) == 0)){
                String subTotalAlt = FunctionsXML.getTagValueHTML(TaxTotalNodeList, "cbc:LineExtensionAmount");
                if (NumberUtils.stringIsBigDecimal(subTotalAlt)) {
                    subTotal = (new BigDecimal(subTotalAlt).compareTo(BigDecimal.ZERO) > 0) ? subTotalAlt : (new BigDecimal(montoTotal).subtract(new BigDecimal(igv))).toString();
                }
            }

            String[] refFacturaStrings = referenciaFactura.split("-");
            serieComprobante =  refFacturaStrings[0];
            nroComprobante = refFacturaStrings[1];

            BillConsultPortBidingServiceLocator locator =  new BillConsultPortBidingServiceLocator ();
            locator.setBillConsultServicePortEndpointAddress("https://www.sunat.gob.pe/ol-it-wsconscpegem/billConsultService");
            BillConsultService port = locator.getBillConsultServicePort();
            Stub stub = ((Stub) port) ;
            int nroComprobanteInteger = Integer.parseInt(nroComprobante + "");
            SOAPHeaderElement wsseSecurity = new SOAPHeaderElement(new PrefixedQName("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd","Security", "wsse"));
            MessageElement usernameToken = new MessageElement("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:UsernameToken");
            MessageElement username = new MessageElement("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:Username");
            MessageElement password = new MessageElement("http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd", "wsse:Password");

            username.setObjectValue(rucCliente.concat(repositoryUser));
            usernameToken.addChild(username);
            password.setObjectValue(repositoryPass);
            usernameToken.addChild(password);
            wsseSecurity.addChild(usernameToken);
            stub.setHeader(wsseSecurity);
            StatusResponse ff = port.getStatus(rucProveedor, tipoComprobante, serieComprobante, nroComprobanteInteger);

            codess = ff.getStatusCode();
            messages = ff.getStatusMessage();
            if (codess.equalsIgnoreCase("0001") || codess.equalsIgnoreCase("0009") || codess.equalsIgnoreCase("0010")) {
                bean.setType("S");
                bean.setMensaje(messages);
            } else {
                bean.setType("E");
                bean.setMensaje(messages);
            }

            String fechaEmisionString = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:IssueDate");
            String codigoMoneda = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:DocumentCurrencyCode");
            Date fechaEmision = DateUtils.stringToUtilDate (fechaEmisionString);
//            Sociedad sociedad = sociedadService.getOneByRucCliente(rucCliente);
//            prefactura.setSociedad(sociedad != null ? sociedad.getCodigoSociedad() : "");

            prefactura.setSociedad("");
            prefactura.setProveedorRuc(rucProveedor);
            prefactura.setFechaEmision(fechaEmision);
            prefactura.setReferencia(referenciaFactura);
            prefactura.setCodigoMoneda(codigoMoneda);
            prefactura.setIgv(igv);
            prefactura.setSubTotal(subTotal);
            prefactura.setTotal(montoTotal);
            // prefactura.setObservaciones(    );

            bean.setPrefactura(prefactura);
            if (sunatXml.exists()) {
                sunatXml.delete();
            }


        } catch (IOException e) {
            messages = e.toString();
            bean.setType("EX");
            if(messages.equalsIgnoreCase("El Usuario ingresado no existe")) { // si el RUC del receptor no es uno valido, el usuario de autenticacion generado usando dicho RUC no es correcto
                messages = "El receptor no es el correcto";
            }
            bean.setMensaje(messages);
            System.out.println(e.toString());
        }catch (Exception e) {
            // TODO: handle exception
            messages = e.toString();
            bean.setType("EL");
            bean.setMensaje(messages);
            System.out.println(e.toString());
        }

        return new ResponseEntity<>(bean, HttpStatus.OK);
    }

    @ApiOperation(value = "Devuelve datos del Comprobante XML", produces = "application/json")
    @PostMapping(value = "/_leerComprobante",produces = {MediaType.APPLICATION_JSON_VALUE})
    public ResponseEntity<PrefacturaDto> LeerComprobante(@RequestParam(value = "file") MultipartFile archivoSunat){
        PrefacturaDto prefactura = new PrefacturaDto();

        try {
            File sunatXml = FunctionsXML.convert(archivoSunat);
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();
            Document doc = db.parse(sunatXml);

            XPath xPath = XPathFactory.newInstance().newXPath();
            String referenciaFactura = xPath.compile("/Invoice/ID").evaluate(doc);
            String igvAlt = xPath.compile("/Invoice/TaxTotal/TaxAmount").evaluate(doc);
//            String subTotal = xPath.compile("/Invoice/TaxTotal/TaxSubtotal/TaxableAmount").evaluate(doc);
            String rucProveedorAlt = xPath.compile("/Invoice/AccountingSupplierParty/Party/PartyIdentification/ID").evaluate(doc);
            String rucClienteAlt = xPath.compile("/Invoice/AccountingCustomerParty/Party/PartyIdentification/ID").evaluate(doc);

            doc.getDocumentElement().normalize();
            NodeList ProveedorNodeList = doc.getElementsByTagName("cac:AccountingSupplierParty");
            NodeList ClienteNodeList = doc.getElementsByTagName("cac:AccountingCustomerParty");
            NodeList FacturaNodeList = doc.getElementsByTagName("Invoice");
            NodeList TaxSubTotalNodeList = doc.getElementsByTagName("cac:TaxTotal");
            NodeList TaxTotalNodeList = doc.getElementsByTagName("cac:LegalMonetaryTotal");

//            String rucProveedor = FunctionsXML.getTagValueByAttributeHTML(ProveedorNodeList, "cbc:ID","schemeAgencyName", "PE:SUNAT");
//            String rucCliente = FunctionsXML.getTagValueByAttributeHTML(ClienteNodeList, "cbc:ID","schemeAgencyName", "PE:SUNAT");
//            String rucProveedor = FunctionsXML.getTagValueByAttributeHTML(ProveedorNodeList, "cbc:ID","schemeID", "6");
//            String rucCliente = FunctionsXML.getTagValueByAttributeHTML(ClienteNodeList, "cbc:ID","schemeID", "6");
            String rucProveedor = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:ID");
            String rucCliente = FunctionsXML.getTagValueHTML(ClienteNodeList, "cbc:ID");

            if(!NumberUtils.stringIsLong(rucProveedor) && rucProveedor.length() != 11){
                rucProveedor = rucProveedorAlt;
            }

            if(!NumberUtils.stringIsLong(rucCliente) && rucCliente.length() != 11){
                rucCliente = rucClienteAlt;
            }

//            String referenciaFactura = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:ID");
            String tipoComprobante = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:InvoiceTypeCode");
            String montoTotal = FunctionsXML.getTagValueHTML(TaxTotalNodeList, "cbc:PayableAmount");
            List<String> taxSubTotalList = FunctionsXML.getTagValueIntoTagHTML(TaxSubTotalNodeList, "cbc:Name", "IGV", "cbc:TaxAmount","cbc:TaxableAmount" );
            String igv = taxSubTotalList.get(0);
            String subTotal = taxSubTotalList.get(1);

            if(!NumberUtils.stringIsBigDecimal(igv) || ((new BigDecimal(igv).compareTo(BigDecimal.ZERO)) == 0 && (new BigDecimal(igvAlt).compareTo(BigDecimal.ZERO)) > 0)) {
                igv = igvAlt;
            }

            if(!NumberUtils.stringIsBigDecimal(subTotal) || ((new BigDecimal(subTotal).compareTo(BigDecimal.ZERO)) == 0)){
                String subTotalAlt = FunctionsXML.getTagValueHTML(TaxTotalNodeList, "cbc:LineExtensionAmount");
                if (NumberUtils.stringIsBigDecimal(subTotalAlt)) {
                    subTotal = (new BigDecimal(subTotalAlt).compareTo(BigDecimal.ZERO) > 0) ? subTotalAlt : (new BigDecimal(montoTotal).subtract(new BigDecimal(igv))).toString();
                }
            }
            String[] refFacturaStrings = referenciaFactura.split("-");
            String serieComprobante =  refFacturaStrings[0];
            String nroComprobante = refFacturaStrings[1];
            String razonSocial = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:RegistrationName");


            String fechaEmisionString = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:IssueDate");
            String codigoMoneda = FunctionsXML.getTagValueHTML(FacturaNodeList, "cbc:DocumentCurrencyCode");
            Date fechaEmision = DateUtils.stringToUtilDate (fechaEmisionString);
//            Sociedad sociedad = sociedadService.getOneByRucCliente(rucCliente);
//            prefactura.setSociedad(sociedad != null ? sociedad.getCodigoSociedad() : "");

            prefactura.setSociedad("");
            prefactura.setProveedorRuc(rucProveedor);
            prefactura.setFechaEmision(fechaEmision);
            prefactura.setReferencia(referenciaFactura);
            prefactura.setCodigoMoneda(codigoMoneda);
            prefactura.setIgv(igv);
            prefactura.setSubTotal(subTotal);
            prefactura.setTotal(montoTotal);
            prefactura.setObservaciones("RUC Cliente: " + rucCliente + " // Tipo Comprobante: " + tipoComprobante);
            prefactura.setTipoComprobante(tipoComprobante);
            prefactura.setSerieComprobante(serieComprobante);
            prefactura.setNroComprobante(nroComprobante);
            prefactura.setRazonSocial(razonSocial);

            String cityName = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:CityName");
            String countrySubentity = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:CountrySubentity");
            //String countrySubentityCode = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:CountrySubentityCode");
            String district = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:District");
            String direccion = FunctionsXML.getTagValueHTML(ProveedorNodeList, "cbc:Line");

            prefactura.setCityName(cityName);
            prefactura.setCountrySubentity(countrySubentity);
            //prefactura.setCountrySubentityCode(countrySubentityCode);
            prefactura.setDistrict(district);
            prefactura.setDireccion(direccion);
            if (sunatXml.exists()) {
                sunatXml.delete();
            }

            return new ResponseEntity<>(prefactura, HttpStatus.OK);
        }
        catch (Exception e) {
            String error = Utils.obtieneMensajeErrorException(e);
            throw new RuntimeException(error);
        }
    }

    @ApiOperation(value = "Graba adjunto de Factura (TIPO FACTURA) en la carpeta Temporal", produces = "application/json")
    @PostMapping(value = "/_agregarAdjuntoTemporalTipoFactura", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacDocumentoAdjunto> agregarAdjuntoTemporalTipoFactura(
            @RequestParam("file") MultipartFile file) throws Exception {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Agregando agregarAdjuntoTemporalTipoFactura  [" + file.getName() + " , " +
                file.getSize() + " ]");
        try {
            FacDocumentoAdjunto result = this.facFacturaDeltaService
                    .agregarAdjuntoTemporal(file, TipoFacturaAdjuntoEnum.FAC_FACTU.getEstado());
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Graba adjunto de Factura (TIPO GUIA REMISION) en la carpeta Temporal", produces = "application/json")
    @PostMapping(value = "/_agregarAdjuntoTemporalTipoGuia", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacDocumentoAdjunto> agregarAdjuntoTemporalTipoGuia(
            @RequestParam("file") MultipartFile file) throws Exception {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Agregando agregarAdjuntoTemporalTipoGuia  [" + file.getName() + " , " +
                file.getSize() + " ]");
        try {
            FacDocumentoAdjunto result = this.facFacturaDeltaService
                    .agregarAdjuntoTemporal(file, TipoFacturaAdjuntoEnum.FAC_GUIA.getEstado());
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Graba adjunto de Factura (TIPO CDR) en la carpeta Temporal", produces = "application/json")
    @PostMapping(value = "/_agregarAdjuntoTemporalTipoCdr", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacDocumentoAdjunto> agregarAdjuntoTemporalTipoCdr(
            @RequestParam("file") MultipartFile file) throws Exception {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Agregando agregarAdjuntoTemporalTipoCdr  [" + file.getName() + " , " +
                file.getSize() + " ]");
        try {
            FacDocumentoAdjunto result = this.facFacturaDeltaService
                    .agregarAdjuntoTemporal(file, TipoFacturaAdjuntoEnum.FAC_CDR.getEstado());
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }


    @ApiOperation(value = "Graba adjunto de Factura (TIPO OTROS) en la carpeta Temporal", produces = "application/json")
    @PostMapping(value = "/_agregarAdjuntoTemporalTipoOtros", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacDocumentoAdjunto> agregarAdjuntoTemporalTipoOtros(
            @RequestParam("file") MultipartFile file) throws Exception {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Agregando agregarAdjuntoTemporalTipoOtros  [" + file.getName() + " , " +
                file.getSize() + " ]");
        try {
            FacDocumentoAdjunto result = this.facFacturaDeltaService
                    .agregarAdjuntoTemporal(file, TipoFacturaAdjuntoEnum.FAC_OTROS.getEstado());
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }


    @ApiOperation(value = "Elimina Archivo Adjunto de Factura", produces = "application/json")
    @PostMapping(value = "/_deleteAdjunto/{archivoId}", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<String> deleteAdjunto(@PathVariable("archivoId") String archivoId)
            throws Exception {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Agregando deleteAdjunto: " + archivoId);
        try {
            String result = this.facFacturaDeltaService.deleteAdjunto(archivoId);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }


    @ApiOperation(value = "Devuelve Factura con sus datos hijos en base al ID de Factura ingresado", produces = "application/json")
    @GetMapping(value = "/_devuelveFactura/{facFacturaId}", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacFacturaDto> devuelveFactura(
            @PathVariable Integer facFacturaId
    ) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando _devuelveFactura by: " + facFacturaId) ;
        try {
            FacFacturaDto result = this.facFacturaDeltaService.devuelveFactura(facFacturaId);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Graba Factura con sus datos hijos en base a los parametros ingresados", produces = "application/json")
    @PostMapping(value = "/_grabarFactura", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<FacFacturaDto> grabarFactura(@RequestBody FacFacturaDto bean) throws URISyntaxException {
        HttpHeaders headers = new HttpHeaders();
        log.debug("Ingresando grabarFactura by: " + bean.toString()) ;
        try {
            FacFacturaDto result = this.facFacturaDeltaService.grabarFactura(bean);
            this.facFacturaDeltaService.enviarEmailFactura(result);
            return Optional.ofNullable(result)
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }


    @ApiOperation(value = "Devuelve lista de registros de tipo FacFactura en base al Proveedor ingresados en forma Paginada", produces = "application/json")
    @PostMapping(value = "/_findCondicionProveedorPaginated", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<PageResponse<FacFactura>> findCondicionProveedorPaginated(
            @RequestBody FacFacturaResponse bean, BindingResult bindingResult) throws URISyntaxException {
        BindingErrorsResponse errors = new BindingErrorsResponse();
        HttpHeaders headers = new HttpHeaders();
        if (bindingResult.hasErrors()) {
            String errorDevuelve = this.devuelveErrorHeaders(bindingResult, errors);
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        if (!Optional.ofNullable(bean.getPageRequest()).isPresent()) {
            String errorDevuelve = "Debe ingresar Bean de Paginación (PageRequest)";
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        PageRequest pageRequest = bean.getPageRequest().toPageRequest();
        log.debug("Ingresando findCondicionProveedorPaginated by:" + bean.toString());
        try {
            PageResponse<FacFactura> result = this.facFacturaDeltaService.findCondicionProveedorPaginated(bean, pageRequest);
            return Optional.ofNullable(result).map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        } catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }


    @ApiOperation(value = "Devuelve lista de registros de tipo FacFactura en base al Proveedor y en base a los parámetros ingresados", produces = "application/json")
    @PostMapping(value = "/_findProveedor", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<List<FacFactura>> findProveedor(@RequestBody FacFactura bean, BindingResult bindingResult) throws URISyntaxException {
        BindingErrorsResponse errors = new BindingErrorsResponse();
        HttpHeaders headers = new HttpHeaders();
        if (bindingResult.hasErrors()) {
            String errorDevuelve = this.devuelveErrorHeaders(bindingResult, errors);
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        log.debug("Ingresando findProveedor by:" + bean.toString());
        try {
            return Optional.ofNullable(this.facFacturaDeltaService.findProveedor(bean))
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }

    @ApiOperation(value = "Devuelve lista de registros de tipo FacFactura en base al Proveedor y en base a los parámetros y condiciones ingresados ", produces = "application/json")
    @PostMapping(value = "/_findCondicionProveedor", produces = APPLICATION_JSON_VALUE)
    public ResponseEntity<List<FacFactura>> findCondicionProveedor(@RequestBody FacFacturaResponse bean, BindingResult bindingResult) throws URISyntaxException {
        BindingErrorsResponse errors = new BindingErrorsResponse();
        HttpHeaders headers = new HttpHeaders();
        if (bindingResult.hasErrors()) {
            String errorDevuelve = this.devuelveErrorHeaders(bindingResult, errors);
            if (this.devuelveRuntimeException) {
                throw new RuntimeException(errorDevuelve);
            }
            headers.add("errors", errorDevuelve);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
        log.debug("Ingresando findCondicionProveedor by:" + bean.toString());
        try {
            return Optional.ofNullable(this.facFacturaDeltaService.findCondicionProveedor(bean))
                    .map(l -> new ResponseEntity<>(l, HttpStatus.OK))
                    .orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }



    @ApiOperation(value = "Listado criterio facFactura", produces = "application/json")
    @RequestMapping(value = "/listCriterioFacFactura", method = RequestMethod.POST, headers = "Accept=application/json")
    ResponseEntity<List<FacFactura>> listCriterioFacFactura(@RequestBody FacFactura facFactura)
            throws Exception {
        return Optional.of(new ResponseEntity<List<FacFactura>>(
                this.facFacturaDeltaRepository.find(facFactura),
                HttpStatus.OK)).orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
    }


    @RequestMapping(value = "/adjunto/{tipoAdjunto}", method = RequestMethod.POST, produces = {
            MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ResponseEntity<?> facturaAdjunto(
            @PathVariable("tipoAdjunto") String tipoAdjunto,
            @RequestParam("file") MultipartFile file
    ) throws Exception {
        log.debug("facturaAdjunto: [" + file.getName() + " , " +
                file.getSize() + " ]");
        return Optional.ofNullable(this.facFacturaDeltaService.facturaAdjunto(file, tipoAdjunto))
                .map(oj -> {
                    Map response = new HashMap<>();
                    response.put("data", oj);
                    return response;
                })
                .map(response -> new ResponseEntity<>(response, HttpStatus.OK))
                .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND));
    }

    @RequestMapping(value = "/deleteOneFile/{fileID}", method = RequestMethod.POST, produces = {
            MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ResponseEntity<?> deleteOneFile(@PathVariable("fileID") String fileID) {
        HttpHeaders headers = new HttpHeaders();
        try {
            return Optional.of(new ResponseEntity<List<String>>(
                    this.facFacturaDeltaService.deleteOneFile(fileID),
                    HttpStatus.OK)).orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
        }
        catch (Exception e) {
            if (this.devuelveRuntimeException) {
                String error = Utils.obtieneMensajeErrorExceptionDepurado(e);
                throw new RuntimeException(error);
            }
            headers = this.devuelveErrorHeaders(e);
            return new ResponseEntity<>(headers, HttpStatus.BAD_REQUEST);
        }
    }


    @RequestMapping(value = "/factura/listaAdjuntos/{facturaID}", method = RequestMethod.POST, produces = {
            MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ResponseEntity<?> listaAdjuntos(@PathVariable("facturaID") Integer facturaID) {
        return Optional.of(new ResponseEntity<List<FacDocumentoAdjunto>>(
                this.facFacturaDeltaService.listaAdjuntos(facturaID),
                HttpStatus.OK)).orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
    }

    @RequestMapping(value = "/factura/deleteAllFilesCMIS", method = RequestMethod.POST, produces = {
            MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public ResponseEntity<?> deleteAllFilesCMIS() {
        return Optional.of(new ResponseEntity<List<CmisFile>>(
                this.facFacturaDeltaService.deleteAllFilesCMIS(),
                HttpStatus.OK)).orElse(new ResponseEntity<>(HttpStatus.NO_CONTENT));
    }



}
